<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Maximum Reality: The Bureaucracy Heist</title>
    <style>
        :root { --neon: #00f3ff; --danger: #ff0055; --gold: #ffcf00; --matrix: #00ff41; }
        body { margin: 0; padding: 0; background-color: #050505; overflow: hidden; height: 100dvh; font-family: 'Courier New', monospace; color: white; }
        canvas { width: 100vw; height: 100dvh; display: block; touch-action: none; }
        
        #ui, .overlay, #game-controls { position: absolute; width: 100%; box-sizing: border-box; }
        #ui { top: 10px; left: 0; display: flex; justify-content: space-between; padding: 0 20px; pointer-events: none; z-index: 10; }
        .stat { color: var(--neon); text-shadow: 0 0 5px var(--neon); font-weight: bold; }
        #game-controls { bottom: 20px; right: 20px; display: flex; gap: 10px; width: auto; z-index: 100; }
        .ctrl-btn { background: rgba(0,0,0,0.7); border: 1px solid var(--neon); color: var(--neon); padding: 10px; border-radius: 5px; font-size: 18px; cursor: pointer; pointer-events: auto; }

        .overlay { 
            top: 0; left: 0; height: 100%; background: rgba(0,0,0,0.9); 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; padding: 30px; z-index: 200; pointer-events: auto;
        }
        h1 { color: var(--neon); margin-bottom: 10px; font-size: 28px; text-transform: uppercase; }
        .story { font-size: 14px; line-height: 1.5; max-width: 450px; color: #ccc; margin-bottom: 20px; }
        .start-btn { background: var(--neon); color: black; border: none; padding: 15px 40px; font-weight: bold; font-family: inherit; font-size: 20px; border-radius: 5px; cursor: pointer; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="stat">SCORE: <span id="score">0</span></div>
        <div class="stat">BEST: <span id="high-score">0</span></div>
    </div>

    <div id="game-controls">
        <button class="ctrl-btn" onclick="togglePause()" id="pause-btn">‚è∏Ô∏è</button>
        <button class="ctrl-btn" onclick="toggleMute()" id="mute-btn">üîä</button>
        <button class="ctrl-btn" onclick="location.reload()">üîÑ</button>
    </div>

    <div id="overlay" class="overlay">
        <h1>THE BUREAUCRACY HEIST</h1>
        <p class="story">Lqli√¢a, Morocco. SSA Docs Received in Good Condition.<br>Catch ü•ñ and üìß. Dodge üíä. Look for <b>Azul</b> to hack the system.</p>
        <button class="start-btn" onclick="startGame()">INITIATE HEIST</button>
    </div>

    <div id="game-over" class="overlay" style="display:none;">
        <h1 style="color:var(--danger)">HEIST INTERRUPTED</h1>
        <h2 id="final-score-display">FINAL SCORE: 0</h2>
        <button class="start-btn" onclick="location.reload()">RE-INITIALIZE</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score');
        const overlay = document.getElementById('overlay');
        const gameOverOverlay = document.getElementById('game-over');

        // Assets
        const bg = new Image(); bg.src = 'cyberpunk_city_bg.JPG'; 
        const sprites = {};
        ['arms_up', 'stand_west', 'idle', 'stand_east', 'reach', 'stand', 'azul'].forEach(name => {
            sprites[name] = new Image();
            sprites[name].src = name === 'azul' ? 'helper-azul.png' : `lori_${name}.png`;
        });

        const sounds = {
            ssa_form: new Audio('youve-got-mail.mp3'),
            khobz: new Audio('crunch.mp3'),
            michelin_star: new Audio('chime.mp3'),
            spam: new Audio('error.mp3'),
            macy_ghost: new Audio('whoosh.mp3'),
            azul_meow: new Audio('azul-hacker-meow.mp3')
        };

        let gameState = {
            mode: 'menu',
            player: { x: window.innerWidth / 2, y: window.innerHeight - 150 }, 
            score: 0,
            highScore: localStorage.getItem('maxReality_highScore') || 0,
            isMuted: false, isPaused: false, difficulty: 1.0,
            powerUpActive: false, powerUpTimer: 0,
            movingLeft: false, movingRight: false, currentSprite: 'stand'
        };

        let obstacles = [], particles = [], startTime = 0;
        highScoreElement.innerText = gameState.highScore;

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.size = Math.random() * 4 + 2;
                this.speedX = (Math.random() - 0.5) * 8; this.speedY = (Math.random() - 0.5) * 8;
                this.color = color; this.alpha = 1;
            }
            update() { this.x += this.speedX; this.y += this.speedY; this.alpha -= 0.02; }
            draw() { ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
        }

        function startGame() {
            overlay.style.display = 'none';
            gameState.mode = 'playing';
            startTime = Date.now();
            Object.values(sounds).forEach(s => { s.play().then(() => { s.pause(); s.currentTime = 0; }).catch(()=>{}) });
            setInterval(spawnObstacle, 1000);
            requestAnimationFrame(gameLoop);
        }

        function spawnObstacle() {
            if (gameState.mode !== 'playing' || gameState.isPaused) return;
            const types = [
                { label: "ü•ñ", type: "khobz", value: 10 },
                { label: "üìß", type: "ssa_form", value: 50 },
                { label: "‚≠ê", type: "michelin_star", value: 100 },
                { label: "üíä", type: "spam_capsule", value: -50 },
                { label: "üíî", type: "spam", value: -20 },
                { label: "üëª", type: "macy_ghost", value: 0 }
            ];
            
            let choice = (Math.random() < 0.08) ? { label: "azul", type: "azul_powerup", value: 0 } : types[Math.floor(Math.random() * types.length)];
            
            obstacles.push({ 
                x: Math.random() * (canvas.width - 40), y: -50, 
                speed: (2 + Math.random() * 3) * (gameState.powerUpActive ? 0.6 : gameState.difficulty), 
                ...choice 
            });
        }

        function update() {
            if (gameState.mode !== 'playing' || gameState.isPaused) return;

            if (gameState.powerUpActive) {
                gameState.powerUpTimer--;
                if (gameState.powerUpTimer <= 0) gameState.powerUpActive = false;
            } else {
                gameState.difficulty = 1 + ((Date.now() - startTime) / 1000 * 0.02);
            }

            if (gameState.movingLeft) gameState.player.x -= 8;
            if (gameState.movingRight) gameState.player.x += 8;
            gameState.player.x = Math.max(50, Math.min(canvas.width - 50, gameState.player.x));

            let reaching = false;
            particles.forEach((p, i) => { p.update(); if (p.alpha <= 0) particles.splice(i, 1); });

            obstacles.forEach((ob, i) => {
                if (gameState.powerUpActive && ob.value > 0) {
                    let dx = gameState.player.x - ob.x, dy = gameState.player.y - ob.y;
                    let angle = Math.atan2(dy, dx);
                    ob.x += Math.cos(angle) * 6; ob.y += Math.sin(angle) * 6;
                } else { ob.y += ob.speed; }

                let dist = Math.sqrt((gameState.player.x - ob.x)**2 + (gameState.player.y - ob.y)**2);

                if (dist < 60) {
                    if (ob.type === 'azul_powerup') {
                        gameState.powerUpActive = true; gameState.powerUpTimer = 450;
                        if (!gameState.isMuted) sounds.azul_meow.play();
                    } else {
                        if (sounds[ob.type] && !gameState.isMuted) { sounds[ob.type].currentTime = 0; sounds[ob.type].play(); }
                        if (ob.value > 0) for(let j=0; j<12; j++) particles.push(new Particle(ob.x, ob.y, ob.type==='ssa_form'?'#00f3ff':'#ffcf00'));
                        gameState.score += ob.value;
                    }
                    obstacles.splice(i, 1);
                    scoreElement.innerText = gameState.score;
                    if (gameState.score > gameState.highScore) {
                        gameState.highScore = gameState.score;
                        highScoreElement.innerText = gameState.highScore;
                        localStorage.setItem('maxReality_highScore', gameState.highScore);
                    }
                    if (gameState.score < -200) { gameState.mode = 'gameOver'; gameOverOverlay.style.display = 'flex'; document.getElementById('final-score-display').innerText = `FINAL SCORE: ${gameState.score}`; }
                }
                if (dist < 130 && ob.value > 0) reaching = true;
            });

            if (reaching) gameState.currentSprite = 'reach';
            else if (gameState.movingLeft) gameState.currentSprite = 'stand_west';
            else if (gameState.movingRight) gameState.currentSprite = 'stand_east';
            else gameState.currentSprite = 'stand';

            obstacles = obstacles.filter(ob => ob.y < canvas.height);
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (bg.complete) {
                ctx.filter = gameState.powerUpActive ? 'sepia(100%) hue-rotate(90deg) brightness(40%) contrast(150%)' : 'grayscale(100%) brightness(30%) contrast(110%)';
                ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
                ctx.filter = 'none';
            }
            particles.forEach(p => p.draw());
            const img = sprites[gameState.currentSprite];
            if (img && img.complete) ctx.drawImage(img, gameState.player.x - 50, gameState.player.y - 75, 100, 150);
            
            obstacles.forEach(ob => {
                if (ob.type === 'azul_powerup') {
                    if (sprites.azul.complete) ctx.drawImage(sprites.azul, ob.x - 30, ob.y - 30, 60, 60);
                } else {
                    ctx.font = "40px serif"; ctx.fillText(ob.label, ob.x - 20, ob.y);
                }
            });
            update();
            requestAnimationFrame(gameLoop);
        }

        canvas.addEventListener('touchmove', (e) => {
            if (gameState.mode !== 'playing' || gameState.isPaused) return;
            gameState.player.x = e.touches[0].clientX;
            e.preventDefault();
        }, { passive: false });

        function togglePause() { gameState.isPaused = !gameState.isPaused; document.getElementById('pause-btn').innerText = gameState.isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è'; }
        function toggleMute() { gameState.isMuted = !gameState.isMuted; document.getElementById('mute-btn').innerText = gameState.isMuted ? 'üîá' : 'üîä'; }
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; gameState.player.y = canvas.height - 150; });
    </script>
</body>
</html>
