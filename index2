<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Maximum Reality: The Bureaucracy Heist</title>
    <style>
        body { margin: 0; padding: 0; background-color: #0a0a0a; overflow: hidden; height: 100dvh; font-family: 'Courier New', monospace; }
        canvas { width: 100vw; height: 100dvh; display: block; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; color: #00f3ff; pointer-events: none; text-shadow: 0 0 5px #00f3ff; font-weight: bold; z-index: 10; }
    </style>
</head>
<body>

    <div id="ui">SCORE: <span id="score">0</span></div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        // 1. Assets (Images & Sound)
        const bg = new Image();
        bg.src = 'cyberpunk_city_bg.JPG'; 

        const sprites = {};
        const frameNames = ['arms_up', 'stand_west', 'idle', 'stand_east', 'reach', 'stand'];
        frameNames.forEach(name => {
            sprites[name] = new Image();
            sprites[name].src = `lori_${name}.png`;
        });

        const sounds = {
            ssa_form: new Audio('youve-got-mail.mp3'), // Fixed lowercase 'y'
            khobz: new Audio('crunch.mp3'),
            michelin_star: new Audio('chime.mp3'),
            spam: new Audio('error.mp3'),
            macy_ghost: new Audio('whoosh.mp3')
        };

        let audioUnlocked = false;

        // 2. State
        let gameState = {
            player: { x: window.innerWidth / 2, y: window.innerHeight - 150 }, 
            score: 0, movingLeft: false, movingRight: false, currentSprite: 'stand'
        };
        let obstacles = [];

        // 3. Setup Functions
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gameState.player.y = canvas.height - 150; 
        }
        window.addEventListener('resize', resize);
        resize();

        function unlockAudio() {
            if (audioUnlocked) return;
            Object.values(sounds).forEach(s => {
                s.play().then(() => { s.pause(); s.currentTime = 0; }).catch(() => {});
            });
            audioUnlocked = true;
        }

        function spawnObstacle() {
            const types = [
                { label: "ðŸ¥–", type: "khobz", value: 10 },
                { label: "ðŸ’”", type: "spam", value: -20 },
                { label: "ðŸ“§", type: "ssa_form", value: 50 },
                { label: "â­", type: "michelin_star", value: 100 },
                { label: "ðŸ‘»", type: "macy_ghost", value: 0 },
                { label: "ðŸ’Š", type: "spam_capsule", value: -50 }
            ];
            const choice = types[Math.floor(Math.random() * types.length)];
            obstacles.push({
                x: Math.random() * (canvas.width - 40),
                y: -50,
                speed: 3 + Math.random() * 4,
                ...choice
            });
        }

        // 4. Interaction
        canvas.addEventListener('touchmove', (e) => {
            unlockAudio();
            const touch = e.touches[0];
            const newX = touch.clientX;
            gameState.movingLeft = newX < gameState.player.x - 5;
            gameState.movingRight = newX > gameState.player.x + 5;
            gameState.player.x = newX;
            e.preventDefault();
        }, { passive: false });

        // 5. Update & Logic
        function update() {
            let isReaching = false;
            obstacles.forEach((ob, index) => {
                ob.y += ob.speed;
                let dx = gameState.player.x - ob.x;
                let dy = gameState.player.y - ob.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 60) {
                    if (sounds[ob.type]) {
                        sounds[ob.type].currentTime = 0;
                        sounds[ob.type].play();
                    }
                    gameState.score += ob.value;
                    scoreElement.innerText = gameState.score;
                    obstacles.splice(index, 1);
                }
                if (dist < 120 && ob.value > 0) isReaching = true;
            });

            if (isReaching) gameState.currentSprite = 'reach';
            else if (gameState.movingLeft) gameState.currentSprite = 'stand_west';
            else if (gameState.movingRight) gameState.currentSprite = 'stand_east';
            else gameState.currentSprite = 'stand';

            obstacles = obstacles.filter(ob => ob.y < canvas.height);
        }

        // 6. Draw Loop
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (bg.complete) {
                ctx.filter = 'grayscale(100%) brightness(35%) contrast(110%)';
                ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
                ctx.filter = 'none';
            }

            const img = sprites[gameState.currentSprite];
            if (img && img.complete) {
                ctx.drawImage(img, gameState.player.x - 50, gameState.player.y - 75, 100, 150);
            }

            ctx.font = "40px serif";
            obstacles.forEach(ob => { ctx.fillText(ob.label, ob.x, ob.y); });

            update();
            requestAnimationFrame(draw);
        }

        setInterval(spawnObstacle, 1000);
        draw();
    </script>
</body>
</html>
